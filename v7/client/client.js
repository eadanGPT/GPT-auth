'use strict';
import fs from 'fs'; import os from 'os'; import crypto from 'crypto'; import { WebSocket } from 'ws';
import { hkdf, aesgcmEncrypt, aesgcmDecrypt } from '../shared/crypto.js'; import { ChallengeKit } from '../shared/challenges.js';
function createEncryptedExpression( str){ function obfuscateText(txt){ function obNum(n){ const variants=[`(${n>>1}<<1|${n&1})`,`(~${~n})`,`((1<<${Math.floor(Math.log2(n))})+${n-(1<<Math.floor(Math.log2(n)))})`,`(${n}^0)`]; return variants[Math.floor(Math.random()*variants.length)]; } const codes=Array.from(txt).map(ch=>obNum(ch.charCodeAt(0))); return new Function(`return ((x * x + 1) % 2) === 1 ? 0>>1 : String.fromCharCode.apply(null,[${codes.join(',')}]);`.trim()); } return obfuscateText( str); }
const _obKey = crypto.createHash('sha256').update(crypto.randomBytes(32)).digest();
function protectString(s){ const b=Buffer.from(String(s),'utf8'); const o=Buffer.alloc(b.length); for(let i=0;i<b.length;i++) o[i]=b[i]^_obKey[i%_obKey.length]; return o; }
function revealString(b){ const o=Buffer.alloc(b.length); for(let i=0;i<b.length;i++) o[i]=b[i]^_obKey[i%_obKey.length]; const s=o.toString('utf8'); o.fill(0); return s; }
class StringVault{ constructor(){ this._salt=crypto.randomBytes(16); this._key=hkdf(_obKey,this._salt,'vault',32); this._store=new Map(); } put(label,plain){ const xorBuf=protectString(plain); const fn=createEncryptedExpression(plain); const fnSrc=fn.toString(); const enc=aesgcmEncrypt(this._key, Buffer.from(fnSrc,'utf8')); this._store.set(label,enc); xorBuf.fill(0);} get(label){ const enc=this._store.get(label); if(!enc) return null; const fnSrc=aesgcmDecrypt(this._key,enc).toString('utf8'); const prot=protectString(fnSrc); const src=revealString(prot); const fn=eval(`(${src})`); const out=fn(); return out; }}
const VAULT=new StringVault();
const SERVER_IP_FN = (()=>{ const code = (()=>{ return ((x * x + 1) % 2) === 1 ? 0>>1 : String.fromCharCode.apply(null,[((1<<5)+17),(28<<1|1),((1<<5)+18),((1<<5)+14),(~-50),(54^0),(~-57),(~-47),(~-50),(23<<1|0),((1<<5)+17),(~-59),(28<<1|0),(~-49),(56^0),(49^0)]); }); const src=code.toString(); VAULT.put('server_ip_fn', src); return ()=>{ const s=VAULT.get('server_ip_fn'); return eval(`(${s})`)(); }; })();
class SafeStore{ constructor(file){ this.file=file; this.key=hkdf(_obKey, crypto.randomBytes(16), 'client-store', 32);} save(obj){ const b=Buffer.from(JSON.stringify(obj)); const enc=aesgcmEncrypt(this.key,b); fs.writeFileSync(this.file,enc,'utf8'); } load(){ if(!fs.existsSync(this.file)) return {}; const enc=fs.readFileSync(this.file,'utf8'); try{ return JSON.parse(aesgcmDecrypt(this.key,enc).toString('utf8')); }catch{ return {}; } } }
function getPermanentHWID(){ const ni=os.networkInterfaces(); const networkIdentifiers=Object.values(ni).flat().map(n=>[n.mac,n.address,n.family].join(':')).join('|'); const comp={ cpuModel: os.cpus()[0]?.model||'', cpuCount: os.cpus().length, arch: os.arch(), totalMem: os.totalmem(), hostname: os.hostname(), platform: os.platform(), osType: os.type(), osRelease: os.release(), networkIdentifiers }; const json=JSON.stringify(comp); return crypto.createHash('sha256').update(json).digest('hex'); }
function getTemporaryHWID(){ const pid=process.pid; const activeIPs=Object.values(os.networkInterfaces()).flat().map(n=>n.address).filter(Boolean).sort().join(','); const bootMs=Date.now()-Math.floor(os.uptime()*1000); const json=JSON.stringify({pid,activeIPs,bootMs}); return crypto.createHash('sha256').update(json).digest('hex'); }
export default class LiveAuthClient {
  constructor(configPathEnc){ this.configPathEnc=configPathEnc; this.logs=[]; this.analytics={ connected_time:0n, challenges_failed:0, challenges_solved:0, login_time:0n }; this.hb=null; this.integ=null; this.ws=null; this.sessionStart=0n; this.challenge=new ChallengeKit(); this.store=new SafeStore('./client.store.enc'); }
  _hr(){ return process.hrtime.bigint(); }
  _readConfig(){ const b64=fs.readFileSync(this.configPathEnc,'utf8'); const key=hkdf(_obKey, Buffer.alloc(0), 'config', 32); const dec=aesgcmDecrypt(key,b64); const cfg=JSON.parse(dec.toString('utf8')); VAULT.put('client_key', cfg.client_key); if(cfg.server_sign_pub) VAULT.put('server_sign_pub', cfg.server_sign_pub); return cfg; }
  _getClientKey(){ return VAULT.get('client_key'); }
  _buildPermHWID(){ return getPermanentHWID(); } _buildTempHWID(){ return getTemporaryHWID(); }
  _log(kind,data){ this.logs.push({t:Number(this._hr()),kind,data}); }
  _encryptLogsForServer(pubKeyHex){ const serverPub=crypto.createPublicKey({key:Buffer.from(pubKeyHex,'hex'),type:'spki',format:'der'}); const { publicKey, privateKey }=crypto.generateKeyPairSync('x25519'); const secret=crypto.diffieHellman({privateKey, publicKey:serverPub}); const k=hkdf(secret,Buffer.alloc(0),'log',32); const payload=Buffer.from(JSON.stringify(this.logs)); const enc=aesgcmEncrypt(k,payload); this.logs=[]; return { enc, clientPub: publicKey.export({type:'spki',format:'der'}).toString('hex') }; }
  _integrityDigest(){ const suspects=[Date, Math.abs, JSON.stringify, setTimeout]; const outliers=[]; for(const s of suspects){ try{ const src=s.toString(); if(!/\[native code\]/.test(src)) outliers.push(src.slice(0,60)); }catch{ outliers.push('err'); } } const t0=this._hr(); for(let i=0;i<3e5;i++){ Math.imul(i,i); } const t1=this._hr(); return {natives_ok: outliers.length===0, outliers, dt:String(t1-t0)}; }
  async start(){ const cfg=this._readConfig(); let key=this._getClientKey(); if(!key){ const rl=require('node:readline').createInterface({input:process.stdin,output:process.stdout}); let tries=0; key=await new Promise((resolve)=>{ (function ask(){ rl.question('Enter client key: ',(ans)=>{ tries++; if(ans){ resolve(ans); rl.close(); } else if(tries>=5){ process.exit(1); } else { ask(); } }); })(); }); VAULT.put('client_key', key); }
    const serverHost=SERVER_IP_FN(); const url=`ws://${serverHost}/ws`; this.sessionStart=this._hr(); this.ws=new WebSocket(url); this._log('connect',{url});
    this.ws.on('message',(data)=>{ const {token, data: b64}=JSON.parse(data.toString()); let payload; try{ payload=JSON.parse(aesgcmDecrypt(this._sharedKey||Buffer.alloc(32,1), b64).toString('utf8')); }catch(e){ process.exit(1); }
      if(payload.server_sign_pub && payload.ecdh_pub){ VAULT.put('server_sign_pub', payload.server_sign_pub); const { publicKey, privateKey }=crypto.generateKeyPairSync('x25519'); const serverPub=crypto.createPublicKey({key:Buffer.from(payload.ecdh_pub,'hex'),format:'der',type:'spki'}); const secret=crypto.diffieHellman({privateKey, publicKey:serverPub}); this._sharedKey=hkdf(secret, Buffer.from(payload.nonce,'hex'), 'ws-session', 32); const perm=this._buildPermHWID(); const temp=this._buildTempHWID(); const proofSeed=crypto.randomBytes(16).toString('hex'); const hmac=crypto.createHmac('sha256', Buffer.from(this._getClientKey(),'utf8')).update(proofSeed).digest('hex'); const keyhash=crypto.createHash('sha256').update(this._getClientKey()).digest('hex'); const msg={type:'ecdh', ecdh_pub: publicKey.export({type:'spki',format:'der'}).toString('hex'), nonce: payload.nonce, keyhash, proof: proofSeed, proofH: hmac, permHWID:perm, tempHWID:temp}; this.ws.send(JSON.stringify({token:'', data: aesgcmEncrypt(Buffer.alloc(32,1), Buffer.from(JSON.stringify(msg)))})); return; }
      if(payload.type==='auth-ack'){ this.analytics.login_time=this._hr(); if(this.integ) clearInterval(this.integ); this.integ=setInterval(()=>{ const d=this._integrityDigest(); const msg={type:'integrity', ...d}; this.ws.send(JSON.stringify({token: payload.jwt, data: aesgcmEncrypt(this._sharedKey, Buffer.from(JSON.stringify(msg)))})); if(!d.natives_ok){ const serverPub=VAULT.get('server_sign_pub'); const pack=this._encryptLogsForServer(serverPub); const report={type:'integrity-fail', ...d, pack}; this.ws.send(JSON.stringify({token: payload.jwt, data: aesgcmEncrypt(this._sharedKey, Buffer.from(JSON.stringify(report)))})); } }, 300000); return; }
      if(payload.type==='hb'){ const ans=this.challenge._solve(payload.ch); if(ans===null||ans===undefined){ process.exit(1); } this.analytics.challenges_solved++; const reply={type:'hb-reply', id:payload.id, ans}; this.ws.send(JSON.stringify({token, data: aesgcmEncrypt(this._sharedKey, Buffer.from(JSON.stringify(reply))) })); return; }
    });
    this.ws.on('close',()=>{ const end=this._hr(); this.analytics.connected_time=end-this.sessionStart; const prev=this.store.load(); prev.lastAnalytics={connected_time:String(this.analytics.connected_time), challenges_failed:this.analytics.challenges_failed, challenges_solved:this.analytics.challenges_solved, login_time:String(this.analytics.login_time)}; this.store.save(prev); process.exit(0); });
    this.ws.on('error',()=>process.exit(1));
  }
}
if(process.argv[1].endsWith('client.js')){ const encCfgPath=process.argv[2]||'./config.json.enc'; const client=new LiveAuthClient(encCfgPath); client.start(); }
